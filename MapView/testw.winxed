##Include our implemenation
$load 'testp.pbc';  #Note: We can load .pir files too, but I'd rather handle compilation manually.

#Inherit from Rendition
class WRendition : Rendition {
  float polyScale;    #How much to scale the polygon by.
  int polyScaleDec;   #Are we scaling up or down? (boolean)
  var drawables;      #Array of items we plan on drawing.

  var pfxShader;    #Our pixel shader
  var personImg;    #Image of our person
  var spr1;         #First person sprite
  var spr2;         #Second person sprite
  var polygon;      #Our cursor

  function WRendition() {
    #Initialize our polyScale property
    self.polyScale = 1.0;

    #Initialize our polyScaleDec property
    self.polyScaleDec = 1;

    #Initialize our drawables array
    self.drawables = [];

    #Now, start assigning objects to that array.
    int pfxEnabled = PFX_CanUse();
    if (pfxEnabled) {
      #Load the shader
      self.pfxShader = PFX_MakeNew('colorize.sfx');
      if (self.pfxShader) {
        #Set its properties (for now just use the defaults)
        DEMO_SetDefaultPFX(self.pfxShader);

        #Save it in our array of objects
        push(self.drawables, self.pfxShader);
      }
    }

    #Images
    personImg = IMG_MakeNew('person.png')
    if (!personImg) {
      #Error
      throw "Can't load image: person.png";
    }

    #Retrieve the image's width/height, for later
    int w = IMG_GetWidth(personImg) / 2;
    int h = IMG_GetHeight(personImg) / 2;

    #Make sprite 1, set its properties, save it.
    spr1 = SPR_MakeNew();
    SPR_SetImage(spr1, personImg);
    SPR_SetPosition(spr1, 800/3, 600/2);
    SPR_SetCenter(spr1, w, h);
    push(drawables, spr1);

    #Make sprite 2, set its properties, save it.
    spr2 = SPR_MakeNew();
    SPR_SetImage(spr2, personImg);
    SPR_SetPosition(spr2, 2*800/3, 600/2);
    SPR_SetCenter(spr2, w, h);
    push(drawables, spr2);

    #Make our cursor sprite
    polygon = DEMO_InitPoly();
    push(drawables, polygon);
  }

  function flip_poly_point(int id1, int id2) {
    var clr0 = POLY_GetPointColor(polygon, id1);
    var clr1 = POLY_GetPointColor(polygon, id2);
    POLY_SetPointColor(polygon, id1, clr1);
    POLY_SetPointColor(polygon, id2, clr0);
    GAME_DeleteColor(clr0);
    GAME_DeleteColor(clr1);
  }

  function update() {
    #Retrieve game timer
    float frameTimeS = GAME_GetFrameTimeInS()

    #Retrieve mouse x,y
    int mouseX = INPUT_GetMouseX();
    int mouseY = INPUT_GetMouseY();

    #Update our post-effect shader
    if (pfxShader) {
      DEMO_UpdatePFXColor(pfxShader);
    }

    #Update sprite 1's rotation
    float newRot = SPR_GetRotation(spr1) + 50 * frameTimeS;
    SPR_SetRotation(spr1, newRot);

    #Update sprite 1's colorization
    var oldColor = SPR_GetColor(spr1);
    int invScale = (1.0-polyScale) * 255;
    CLR_SetBlue(oldColor, invScale);
    SPR_SetColor(spr1, oldColor);
    GAME_DeleteColor(oldColor);

    #Update sprite 2's rotation
    newRot = SPR_GetRotation(spr2) - 80 * frameTimeS;
    SPR_SetRotation(spr2, newRot);

    #Update sprite 1's colorization
    oldColor = SPR_GetColor(spr2);
    invScale = polyScale * 255;
    CLR_SetAlpha(oldColor, invScale);
    SPR_SetColor(spr2, oldColor);
    GAME_DeleteColor(oldColor);

    #Update our polygon's scale factor
    if (polyScaleDec==1) {
      polyScale -= frameTimeS;
    } else {
      polyScale += frameTimeS;
    }

    #Boundary conditions
    if (polyScale < 0.0) {
      polyScale = 0.0;
      polyScaleDec = 0;
      self.flip_poly_point(1, 5);
      self.flip_poly_point(2, 4);
    }
    if (polyScale > 1.0) {
      polyScale = 1.0;
      polyScaleDec = 1;
    }

    #Set the polyline's x-scale
    POLY_SetScaleX(polygon, polyScale);

    #Set the polyline's position
    POLY_SetPosX(polygon, mouseX);
    POLY_SetPosY(polygon, mouseY);
  }  

  function display() {
    #Draw every item in our array.
    for (var dw in self.drawables) {
      GAME_DrawItem(dw);
    }
  }
}

#Main loop
function main[main](var args)
{
  var currRend = new WRendition;
  run_game(currRend);
}

