##Include our implemenation
$load 'testp.pbc';  #Note: We can load .pir files too, but I'd rather handle compilation manually.

#Inherit from Rendition
class WRendition : Rendition {
  var polyScale;    #How much to scale the polygon by.
  var polyScaleDec;   #Are we scaling up or down? (boolean)
  var drawables;      #Array of items we plan on drawing.

  var pfxShader;    #Our pixel shader
  var personImg;    #Image of our person
  var spr1;         #First person sprite
  var spr2;         #Second person sprite
  var polygon;      #Our cursor

  function WRendition() {
    #Initialize our polyScale property
    self.polyScale = 1.0;

    #Initialize our polyScaleDec property
    self.polyScaleDec = 1;

    #Initialize our drawables array
    self.drawables = [];

    #Now, start assigning objects to that array.
    int pfxEnabled = PFX_CanUse();
    if (pfxEnabled) {
      #Load the shader
      self.pfxShader = PFX_MakeNew('colorize.sfx');
      if (self.pfxShader) {
        #Set its properties (for now just use the defaults)
        DEMO_SetDefaultPFX(self.pfxShader);

        #Save it in our array of objects
        push(self.drawables, self.pfxShader);
      }
    }

    #Images
    self.personImg = IMG_MakeNew('person.png');
    if (!self.personImg) {
      #Error
      throw "Can't load image: person.png";
    }

    #Retrieve the image's width/height, for later
    int w = IMG_GetWidth(self.personImg) / 2;
    int h = IMG_GetHeight(self.personImg) / 2;

    #Make sprite 1, set its properties, save it.
    self.spr1 = SPR_MakeNew();
    SPR_SetImage(self.spr1, self.personImg);
    SPR_SetPosition(self.spr1, 800/3, 600/2);
    SPR_SetCenter(self.spr1, w, h);
    push(self.drawables, self.spr1);

    #Make sprite 2, set its properties, save it.
    self.spr2 = SPR_MakeNew();
    SPR_SetImage(self.spr2, self.personImg);
    SPR_SetPosition(self.spr2, 2*800/3, 600/2);
    SPR_SetCenter(self.spr2, w, h);
    push(self.drawables, self.spr2);

    #Make our cursor sprite
    self.polygon = DEMO_InitPoly();
    push(self.drawables, self.polygon);
  }

  function flip_poly_point(int id1, int id2) {
    var clr0 = POLY_GetPointColor(self.polygon, id1);
    var clr1 = POLY_GetPointColor(self.polygon, id2);
    POLY_SetPointColor(self.polygon, id1, clr1);
    POLY_SetPointColor(self.polygon, id2, clr0);
    GAME_DeleteColor(clr0);
    GAME_DeleteColor(clr1);
  }

  function update() {
    #Retrieve game timer
    float frameTimeS = GAME_GetFrameTimeInS();

    #Retrieve mouse x,y
    int mouseX = INPUT_GetMouseX();
    int mouseY = INPUT_GetMouseY();

    #Update our post-effect shader
    if (self.pfxShader) {
      DEMO_UpdatePFXColor(self.pfxShader);
    }

    #Update sprite 1's rotation
    float newRot = SPR_GetRotation(self.spr1) + 50 * frameTimeS;
    SPR_SetRotation(self.spr1, newRot);

    #Update sprite 1's colorization
    var oldColor = SPR_GetColor(self.spr1);
    float invScale = 1.0 - self.polyScale;
    invScale *= 255;
    CLR_SetBlue(oldColor, invScale);
    SPR_SetColor(self.spr1, oldColor);
    GAME_DeleteColor(oldColor);

    #Update sprite 2's rotation
    newRot = SPR_GetRotation(self.spr2) - 80 * frameTimeS;
    SPR_SetRotation(self.spr2, newRot);

    #Update sprite 1's colorization
    oldColor = SPR_GetColor(self.spr2);
    invScale = self.polyScale;
    invScale *= 255;
    CLR_SetAlpha(oldColor, invScale);
    SPR_SetColor(self.spr2, oldColor);
    GAME_DeleteColor(oldColor);

    #Update our polygon's scale factor
    if (self.polyScaleDec==1) {
      self.polyScale -= frameTimeS;
    } else {
      self.polyScale += frameTimeS;
    }

    #Boundary conditions
    if (self.polyScale < 0.0) {
      self.polyScale = 0.0;
      self.polyScaleDec = 0;
      self.flip_poly_point(1, 5);
      self.flip_poly_point(2, 4);
    }
    if (self.polyScale > 1.0) {
      self.polyScale = 1.0;
      self.polyScaleDec = 1;
    }

    #Set the polyline's x-scale
    POLY_SetScaleX(self.polygon, self.polyScale);

    #Set the polyline's position
    POLY_SetPosX(self.polygon, mouseX);
    POLY_SetPosY(self.polygon, mouseY);
  }  

  function display() {
    #Draw every item in our array.
    for (var dw in self.drawables) {
      GAME_DrawItem(dw);
    }
  }
}

#Main loop
function main[main](var args)
{
  var currRend = new WRendition;
  run_game(currRend);
}

